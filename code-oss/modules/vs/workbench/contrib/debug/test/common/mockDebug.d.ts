import { CancellationToken } from 'vs/base/common/cancellation';
import { Event } from 'vs/base/common/event';
import Severity from 'vs/base/common/severity';
import { URI as uri } from 'vs/base/common/uri';
import { IPosition, Position } from 'vs/editor/common/core/position';
import { ITextModel } from 'vs/editor/common/model';
import { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';
import { AbstractDebugAdapter } from 'vs/workbench/contrib/debug/common/abstractDebugAdapter';
import { AdapterEndEvent, IAdapterManager, IBreakpoint, IBreakpointData, IBreakpointUpdateData, IConfig, IConfigurationManager, IDataBreakpoint, IDebugger, IDebugModel, IDebugService, IDebugSession, IDebugSessionOptions, IEvaluate, IExceptionBreakpoint, IExceptionInfo, IExpression, IFunctionBreakpoint, IInstructionBreakpoint, ILaunch, IMemoryRegion, IRawModelUpdate, IRawStoppedDetails, IReplElement, IReplElementSource, IStackFrame, IThread, IViewModel, LoadedSourceEvent, State } from 'vs/workbench/contrib/debug/common/debug';
import { DebugCompoundRoot } from 'vs/workbench/contrib/debug/common/debugCompoundRoot';
import { Breakpoint, DataBreakpoint, ExceptionBreakpoint, Expression, FunctionBreakpoint } from 'vs/workbench/contrib/debug/common/debugModel';
import { Source } from 'vs/workbench/contrib/debug/common/debugSource';
import { DebugStorage } from 'vs/workbench/contrib/debug/common/debugStorage';
export declare class MockDebugService implements IDebugService {
    _serviceBrand: undefined;
    get state(): State;
    get onWillNewSession(): Event<IDebugSession>;
    get onDidNewSession(): Event<IDebugSession>;
    get onDidEndSession(): Event<IDebugSession>;
    get onDidChangeState(): Event<State>;
    getConfigurationManager(): IConfigurationManager;
    getAdapterManager(): IAdapterManager;
    canSetBreakpointsIn(model: ITextModel): boolean;
    focusStackFrame(focusedStackFrame: IStackFrame): Promise<void>;
    sendAllBreakpoints(session?: IDebugSession): Promise<any>;
    addBreakpoints(uri: uri, rawBreakpoints: IBreakpointData[]): Promise<IBreakpoint[]>;
    updateBreakpoints(uri: uri, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;
    enableOrDisableBreakpoints(enabled: boolean): Promise<void>;
    setBreakpointsActivated(): Promise<void>;
    removeBreakpoints(): Promise<any>;
    addInstructionBreakpoint(address: string, offset: number, condition?: string, hitCondition?: string): Promise<void>;
    removeInstructionBreakpoints(address?: string): Promise<void>;
    setExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string): Promise<void>;
    setExceptionBreakpoints(data: DebugProtocol.ExceptionBreakpointsFilter[]): void;
    addFunctionBreakpoint(): void;
    moveWatchExpression(id: string, position: number): void;
    updateFunctionBreakpoint(id: string, update: {
        name?: string;
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    removeFunctionBreakpoints(id?: string): Promise<void>;
    addDataBreakpoint(label: string, dataId: string, canPersist: boolean): Promise<void>;
    removeDataBreakpoints(id?: string | undefined): Promise<void>;
    addReplExpression(name: string): Promise<void>;
    removeReplExpressions(): void;
    addWatchExpression(name?: string): Promise<void>;
    renameWatchExpression(id: string, newName: string): Promise<void>;
    removeWatchExpressions(id?: string): void;
    startDebugging(launch: ILaunch, configOrName?: IConfig | string, options?: IDebugSessionOptions): Promise<boolean>;
    restartSession(): Promise<any>;
    stopSession(): Promise<any>;
    getModel(): IDebugModel;
    getViewModel(): IViewModel;
    sourceIsNotAvailable(uri: uri): void;
    tryToAutoFocusStackFrame(thread: IThread): Promise<any>;
    runTo(uri: uri, lineNumber: number, column?: number): Promise<void>;
}
export declare class MockSession implements IDebugSession {
    readonly suppressDebugToolbar = false;
    readonly suppressDebugStatusbar = false;
    readonly suppressDebugView = false;
    readonly autoExpandLazyVariables = false;
    getMemory(memoryReference: string): IMemoryRegion;
    get onDidInvalidateMemory(): Event<DebugProtocol.MemoryEvent>;
    readMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;
    writeMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;
    get compoundRoot(): DebugCompoundRoot | undefined;
    get saveBeforeRestart(): boolean;
    get isSimpleUI(): boolean;
    stepInTargets(frameId: number): Promise<{
        id: number;
        label: string;
    }[]>;
    cancel(_progressId: string): Promise<DebugProtocol.CancelResponse>;
    breakpointsLocations(uri: uri, lineNumber: number): Promise<IPosition[]>;
    dataBreakpointInfo(name: string, variablesReference?: number | undefined): Promise<{
        dataId: string | null;
        description: string;
        canPersist?: boolean | undefined;
    } | undefined>;
    sendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;
    subId: string | undefined;
    get compact(): boolean;
    setSubId(subId: string | undefined): void;
    get parentSession(): IDebugSession | undefined;
    getReplElements(): IReplElement[];
    hasSeparateRepl(): boolean;
    removeReplExpressions(): void;
    get onDidChangeReplElements(): Event<void>;
    addReplExpression(stackFrame: IStackFrame, name: string): Promise<void>;
    appendToRepl(data: string | IExpression, severity: Severity, isImportant?: boolean, source?: IReplElementSource): void;
    configuration: IConfig;
    unresolvedConfiguration: IConfig;
    state: State;
    root: IWorkspaceFolder;
    capabilities: DebugProtocol.Capabilities;
    getId(): string;
    getLabel(): string;
    get name(): string;
    setName(name: string): void;
    getSourceForUri(modelUri: uri): Source;
    getThread(threadId: number): IThread;
    getStoppedDetails(): IRawStoppedDetails;
    get onDidCustomEvent(): Event<DebugProtocol.Event>;
    get onDidLoadedSource(): Event<LoadedSourceEvent>;
    get onDidChangeState(): Event<void>;
    get onDidEndAdapter(): Event<AdapterEndEvent | undefined>;
    get onDidChangeName(): Event<string>;
    get onDidProgressStart(): Event<DebugProtocol.ProgressStartEvent>;
    get onDidProgressUpdate(): Event<DebugProtocol.ProgressUpdateEvent>;
    get onDidProgressEnd(): Event<DebugProtocol.ProgressEndEvent>;
    setConfiguration(configuration: {
        resolved: IConfig;
        unresolved: IConfig;
    }): void;
    getAllThreads(): IThread[];
    getSource(raw: DebugProtocol.Source): Source;
    getLoadedSources(): Promise<Source[]>;
    completions(frameId: number, threadId: number, text: string, position: Position, overwriteBefore: number): Promise<DebugProtocol.CompletionsResponse>;
    clearThreads(removeThreads: boolean, reference?: number): void;
    rawUpdate(data: IRawModelUpdate): void;
    initialize(dbgr: IDebugger): Promise<void>;
    launchOrAttach(config: IConfig): Promise<void>;
    restart(): Promise<void>;
    sendBreakpoints(modelUri: uri, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;
    sendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;
    sendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;
    sendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;
    getDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;
    customRequest(request: string, args: any): Promise<DebugProtocol.Response>;
    stackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse>;
    exceptionInfo(threadId: number): Promise<IExceptionInfo>;
    scopes(frameId: number): Promise<DebugProtocol.ScopesResponse>;
    variables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named', start: number, count: number): Promise<DebugProtocol.VariablesResponse>;
    evaluate(expression: string, frameId: number, context?: string): Promise<DebugProtocol.EvaluateResponse>;
    restartFrame(frameId: number, threadId: number): Promise<void>;
    next(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    continue(threadId: number): Promise<void>;
    reverseContinue(threadId: number): Promise<void>;
    pause(threadId: number): Promise<void>;
    terminateThreads(threadIds: number[]): Promise<void>;
    setVariable(variablesReference: number, name: string, value: string): Promise<DebugProtocol.SetVariableResponse>;
    setExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;
    loadSource(resource: uri): Promise<DebugProtocol.SourceResponse>;
    disassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;
    terminate(restart?: boolean): Promise<void>;
    disconnect(restart?: boolean): Promise<void>;
    gotoTargets(source: DebugProtocol.Source, line: number, column?: number | undefined): Promise<DebugProtocol.GotoTargetsResponse>;
    goto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse>;
}
export declare class MockRawSession {
    capabilities: DebugProtocol.Capabilities;
    disconnected: boolean;
    sessionLengthInSeconds: number;
    readyForBreakpoints: boolean;
    emittedStopped: boolean;
    getLengthInSeconds(): number;
    stackTrace(args: DebugProtocol.StackTraceArguments): Promise<DebugProtocol.StackTraceResponse>;
    exceptionInfo(args: DebugProtocol.ExceptionInfoArguments): Promise<DebugProtocol.ExceptionInfoResponse>;
    launchOrAttach(args: IConfig): Promise<DebugProtocol.Response>;
    scopes(args: DebugProtocol.ScopesArguments): Promise<DebugProtocol.ScopesResponse>;
    variables(args: DebugProtocol.VariablesArguments): Promise<DebugProtocol.VariablesResponse>;
    evaluate(args: DebugProtocol.EvaluateArguments): Promise<DebugProtocol.EvaluateResponse>;
    custom(request: string, args: any): Promise<DebugProtocol.Response>;
    terminate(restart?: boolean): Promise<DebugProtocol.TerminateResponse>;
    disconnect(restart?: boolean): Promise<any>;
    threads(): Promise<DebugProtocol.ThreadsResponse>;
    stepIn(args: DebugProtocol.StepInArguments): Promise<DebugProtocol.StepInResponse>;
    stepOut(args: DebugProtocol.StepOutArguments): Promise<DebugProtocol.StepOutResponse>;
    stepBack(args: DebugProtocol.StepBackArguments): Promise<DebugProtocol.StepBackResponse>;
    continue(args: DebugProtocol.ContinueArguments): Promise<DebugProtocol.ContinueResponse>;
    reverseContinue(args: DebugProtocol.ReverseContinueArguments): Promise<DebugProtocol.ReverseContinueResponse>;
    pause(args: DebugProtocol.PauseArguments): Promise<DebugProtocol.PauseResponse>;
    terminateThreads(args: DebugProtocol.TerminateThreadsArguments): Promise<DebugProtocol.TerminateThreadsResponse>;
    setVariable(args: DebugProtocol.SetVariableArguments): Promise<DebugProtocol.SetVariableResponse>;
    restartFrame(args: DebugProtocol.RestartFrameArguments): Promise<DebugProtocol.RestartFrameResponse>;
    completions(args: DebugProtocol.CompletionsArguments): Promise<DebugProtocol.CompletionsResponse>;
    next(args: DebugProtocol.NextArguments): Promise<DebugProtocol.NextResponse>;
    source(args: DebugProtocol.SourceArguments): Promise<DebugProtocol.SourceResponse>;
    loadedSources(args: DebugProtocol.LoadedSourcesArguments): Promise<DebugProtocol.LoadedSourcesResponse>;
    setBreakpoints(args: DebugProtocol.SetBreakpointsArguments): Promise<DebugProtocol.SetBreakpointsResponse>;
    setFunctionBreakpoints(args: DebugProtocol.SetFunctionBreakpointsArguments): Promise<DebugProtocol.SetFunctionBreakpointsResponse>;
    setExceptionBreakpoints(args: DebugProtocol.SetExceptionBreakpointsArguments): Promise<DebugProtocol.SetExceptionBreakpointsResponse>;
    readonly onDidStop: Event<DebugProtocol.StoppedEvent>;
}
export declare class MockDebugAdapter extends AbstractDebugAdapter {
    private seq;
    private pendingResponses;
    startSession(): Promise<void>;
    stopSession(): Promise<void>;
    sendMessage(message: DebugProtocol.ProtocolMessage): void;
    sendResponseBody(request: DebugProtocol.Request, body: any): void;
    sendEventBody(event: string, body: any): void;
    waitForResponseFromClient(command: string): Promise<DebugProtocol.Response>;
    sendRequestBody(command: string, args: any): void;
    evaluate(request: DebugProtocol.Request, args: DebugProtocol.EvaluateArguments): void;
}
export declare class MockDebugStorage extends DebugStorage {
    constructor();
    loadBreakpoints(): Breakpoint[];
    loadFunctionBreakpoints(): FunctionBreakpoint[];
    loadExceptionBreakpoints(): ExceptionBreakpoint[];
    loadDataBreakpoints(): DataBreakpoint[];
    loadWatchExpressions(): Expression[];
    storeWatchExpressions(_watchExpressions: (IExpression & IEvaluate)[]): void;
    storeBreakpoints(_debugModel: IDebugModel): void;
}
