import { Event } from 'vs/base/common/event';
import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
import { URI } from 'vs/base/common/uri';
import { ICodeEditorService } from 'vs/editor/browser/services/codeEditorService';
import { IAccessibilityService } from 'vs/platform/accessibility/common/accessibility';
import { ConfigurationTarget, IConfigurationService } from 'vs/platform/configuration/common/configuration';
import { IFileService } from 'vs/platform/files/common/files';
import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
import { IStorageService } from 'vs/platform/storage/common/storage';
import { NotebookCellTextModel } from 'vs/workbench/contrib/notebook/common/model/notebookCellTextModel';
import { NotebookTextModel } from 'vs/workbench/contrib/notebook/common/model/notebookTextModel';
import { INotebookContributionData, INotebookRendererInfo, IOrderedMimeType, IOutputDto, NotebookData, TransientOptions, NotebookExtensionDescription, INotebookStaticPreloadInfo } from 'vs/workbench/contrib/notebook/common/notebookCommon';
import { INotebookEditorModelResolverService } from 'vs/workbench/contrib/notebook/common/notebookEditorModelResolverService';
import { NotebookOutputRendererInfo } from 'vs/workbench/contrib/notebook/common/notebookOutputRenderer';
import { NotebookProviderInfo } from 'vs/workbench/contrib/notebook/common/notebookProvider';
import { ComplexNotebookProviderInfo, INotebookContentProvider, INotebookSerializer, INotebookService, SimpleNotebookProviderInfo } from 'vs/workbench/contrib/notebook/common/notebookService';
import { IEditorResolverService, IEditorType } from 'vs/workbench/services/editor/common/editorResolverService';
import { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';
export declare class NotebookProviderInfoStore extends Disposable {
    private readonly _editorResolverService;
    private readonly _configurationService;
    private readonly _accessibilityService;
    private readonly _instantiationService;
    private readonly _fileService;
    private readonly _notebookEditorModelResolverService;
    private static readonly CUSTOM_EDITORS_STORAGE_ID;
    private static readonly CUSTOM_EDITORS_ENTRY_ID;
    private readonly _memento;
    private _handled;
    private readonly _contributedEditors;
    private readonly _contributedEditorDisposables;
    constructor(storageService: IStorageService, extensionService: IExtensionService, _editorResolverService: IEditorResolverService, _configurationService: IConfigurationService, _accessibilityService: IAccessibilityService, _instantiationService: IInstantiationService, _fileService: IFileService, _notebookEditorModelResolverService: INotebookEditorModelResolverService);
    dispose(): void;
    private _setupHandler;
    clearEditorCache(): void;
    private _convertPriority;
    private _registerContributionPoint;
    private _clear;
    get(viewType: string): NotebookProviderInfo | undefined;
    add(info: NotebookProviderInfo): IDisposable;
    getContributedNotebook(resource: URI): readonly NotebookProviderInfo[];
    [Symbol.iterator](): Iterator<NotebookProviderInfo>;
}
export declare class NotebookOutputRendererInfoStore {
    private readonly contributedRenderers;
    private readonly preferredMimetypeMemento;
    private readonly preferredMimetype;
    constructor(storageService: IStorageService);
    clear(): void;
    get(rendererId: string): NotebookOutputRendererInfo | undefined;
    getAll(): NotebookOutputRendererInfo[];
    add(info: NotebookOutputRendererInfo): void;
    /** Update and remember the preferred renderer for the given mimetype in this workspace */
    setPreferred(notebookProviderInfo: NotebookProviderInfo, mimeType: string, rendererId: string): void;
    findBestRenderers(notebookProviderInfo: NotebookProviderInfo | undefined, mimeType: string, kernelProvides: readonly string[] | undefined): IOrderedMimeType[];
}
export declare class NotebookService extends Disposable implements INotebookService {
    private readonly _extensionService;
    private readonly _configurationService;
    private readonly _accessibilityService;
    private readonly _instantiationService;
    private readonly _codeEditorService;
    private readonly configurationService;
    readonly _serviceBrand: undefined;
    private readonly _notebookProviders;
    private _notebookProviderInfoStore;
    private get notebookProviderInfoStore();
    private readonly _notebookRenderersInfoStore;
    private readonly _onDidChangeOutputRenderers;
    readonly onDidChangeOutputRenderers: Event<void>;
    private readonly _notebookStaticPreloadInfoStore;
    private readonly _models;
    private readonly _onWillAddNotebookDocument;
    private readonly _onDidAddNotebookDocument;
    private readonly _onWillRemoveNotebookDocument;
    private readonly _onDidRemoveNotebookDocument;
    readonly onWillAddNotebookDocument: Event<NotebookTextModel>;
    readonly onDidAddNotebookDocument: Event<NotebookTextModel>;
    readonly onDidRemoveNotebookDocument: Event<NotebookTextModel>;
    readonly onWillRemoveNotebookDocument: Event<NotebookTextModel>;
    private readonly _onAddViewType;
    readonly onAddViewType: Event<string>;
    private readonly _onWillRemoveViewType;
    readonly onWillRemoveViewType: Event<string>;
    private readonly _onDidChangeEditorTypes;
    onDidChangeEditorTypes: Event<void>;
    private _cutItems;
    private _lastClipboardIsCopy;
    private _displayOrder;
    constructor(_extensionService: IExtensionService, _configurationService: IConfigurationService, _accessibilityService: IAccessibilityService, _instantiationService: IInstantiationService, _codeEditorService: ICodeEditorService, configurationService: IConfigurationService);
    getEditorTypes(): IEditorType[];
    clearEditorCache(): void;
    private _postDocumentOpenActivation;
    canResolve(viewType: string): Promise<boolean>;
    registerContributedNotebookType(viewType: string, data: INotebookContributionData): IDisposable;
    private _registerProviderData;
    registerNotebookController(viewType: string, extensionData: NotebookExtensionDescription, controller: INotebookContentProvider): IDisposable;
    registerNotebookSerializer(viewType: string, extensionData: NotebookExtensionDescription, serializer: INotebookSerializer): IDisposable;
    withNotebookDataProvider(viewType: string): Promise<ComplexNotebookProviderInfo | SimpleNotebookProviderInfo>;
    getRendererInfo(rendererId: string): INotebookRendererInfo | undefined;
    updateMimePreferredRenderer(viewType: string, mimeType: string, rendererId: string, otherMimetypes: readonly string[]): void;
    saveMimeDisplayOrder(target: ConfigurationTarget): void;
    getRenderers(): INotebookRendererInfo[];
    getStaticPreloads(viewType: string): Iterable<INotebookStaticPreloadInfo>;
    createNotebookTextModel(viewType: string, uri: URI, data: NotebookData, transientOptions: TransientOptions): NotebookTextModel;
    getNotebookTextModel(uri: URI): NotebookTextModel | undefined;
    getNotebookTextModels(): Iterable<NotebookTextModel>;
    listNotebookDocuments(): NotebookTextModel[];
    private _onWillDisposeDocument;
    getOutputMimeTypeInfo(textModel: NotebookTextModel, kernelProvides: readonly string[] | undefined, output: IOutputDto): readonly IOrderedMimeType[];
    getContributedNotebookTypes(resource?: URI): readonly NotebookProviderInfo[];
    getContributedNotebookType(viewType: string): NotebookProviderInfo | undefined;
    getNotebookProviderResourceRoots(): URI[];
    setToCopy(items: NotebookCellTextModel[], isCopy: boolean): void;
    getToCopy(): {
        items: NotebookCellTextModel[];
        isCopy: boolean;
    } | undefined;
}
