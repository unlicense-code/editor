import { IMouseWheelEvent } from 'vs/base/browser/mouseEvent';
import { IListRenderer, IListVirtualDelegate } from 'vs/base/browser/ui/list/list';
import { IListStyles, IStyleController } from 'vs/base/browser/ui/list/listWidget';
import { Event } from 'vs/base/common/event';
import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
import { ScrollEvent } from 'vs/base/common/scrollable';
import { Range } from 'vs/editor/common/core/range';
import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
import { IContextKeyService } from 'vs/platform/contextkey/common/contextkey';
import { IListService, IWorkbenchListOptions, WorkbenchList } from 'vs/platform/list/browser/listService';
import { IThemeService } from 'vs/platform/theme/common/themeService';
import { ICellViewModel, ICellOutputViewModel } from 'vs/workbench/contrib/notebook/browser/notebookBrowser';
import { CellViewModel, NotebookViewModel } from 'vs/workbench/contrib/notebook/browser/viewModel/notebookViewModelImpl';
import { ICellRange } from 'vs/workbench/contrib/notebook/common/notebookRange';
import { ViewContext } from 'vs/workbench/contrib/notebook/browser/viewModel/viewContext';
import { BaseCellRenderTemplate, INotebookCellList } from 'vs/workbench/contrib/notebook/browser/view/notebookRenderingCommon';
import { FastDomNode } from 'vs/base/browser/fastDomNode';
import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
export declare const NOTEBOOK_WEBVIEW_BOUNDARY = 5000;
export declare class NotebookCellList extends WorkbenchList<CellViewModel> implements IDisposable, IStyleController, INotebookCellList {
    private listUser;
    get onWillScroll(): Event<ScrollEvent>;
    get rowsContainer(): HTMLElement;
    get scrollableElement(): HTMLElement;
    private _previousFocusedElements;
    private readonly _localDisposableStore;
    private readonly _viewModelStore;
    private styleElement?;
    private readonly _onDidRemoveOutputs;
    readonly onDidRemoveOutputs: Event<readonly ICellOutputViewModel[]>;
    private readonly _onDidHideOutputs;
    readonly onDidHideOutputs: Event<readonly ICellOutputViewModel[]>;
    private readonly _onDidRemoveCellsFromView;
    readonly onDidRemoveCellsFromView: Event<readonly ICellViewModel[]>;
    private _viewModel;
    get viewModel(): NotebookViewModel | null;
    private _hiddenRangeIds;
    private hiddenRangesPrefixSum;
    private readonly _onDidChangeVisibleRanges;
    onDidChangeVisibleRanges: Event<void>;
    private _visibleRanges;
    get visibleRanges(): ICellRange[];
    set visibleRanges(ranges: ICellRange[]);
    private _isDisposed;
    get isDisposed(): boolean;
    private _isInLayout;
    private readonly _viewContext;
    private _webviewElement;
    get webviewElement(): FastDomNode<HTMLElement> | null;
    constructor(listUser: string, container: HTMLElement, viewContext: ViewContext, delegate: IListVirtualDelegate<CellViewModel>, renderers: IListRenderer<CellViewModel, BaseCellRenderTemplate>[], contextKeyService: IContextKeyService, options: IWorkbenchListOptions<CellViewModel>, listService: IListService, themeService: IThemeService, configurationService: IConfigurationService, instantiationService: IInstantiationService);
    attachWebview(element: HTMLElement): void;
    elementAt(position: number): ICellViewModel | undefined;
    elementHeight(element: ICellViewModel): number;
    detachViewModel(): void;
    attachViewModel(model: NotebookViewModel): void;
    private _updateElementsInWebview;
    clear(): void;
    setHiddenAreas(_ranges: ICellRange[], triggerViewUpdate: boolean): boolean;
    private _updateHiddenRangePrefixSum;
    /**
     * oldRanges and newRanges are all reduced and sorted.
     */
    updateHiddenAreasInView(oldRanges: ICellRange[], newRanges: ICellRange[]): void;
    splice2(start: number, deleteCount: number, elements?: CellViewModel[]): void;
    getModelIndex(cell: CellViewModel): number | undefined;
    getModelIndex2(viewIndex: number): number | undefined;
    getViewIndex(cell: ICellViewModel): number | undefined;
    getViewIndex2(modelIndex: number): number | undefined;
    private _getVisibleRangesFromIndex;
    getVisibleRangesPlusViewportAboveAndBelow(): ICellRange[];
    private _getViewIndexUpperBound;
    private _getViewIndexUpperBound2;
    focusElement(cell: ICellViewModel): void;
    selectElements(elements: ICellViewModel[]): void;
    setFocus(indexes: number[], browserEvent?: UIEvent, ignoreTextModelUpdate?: boolean): void;
    setSelection(indexes: number[], browserEvent?: UIEvent | undefined, ignoreTextModelUpdate?: boolean): void;
    /**
     * The range will be revealed with as little scrolling as possible.
     */
    revealElementsInView(range: ICellRange): void;
    isScrolledToBottom(): boolean;
    scrollToBottom(): void;
    revealElementInView(cell: ICellViewModel): void;
    revealElementInViewAtTop(cell: ICellViewModel): void;
    revealElementInCenterIfOutsideViewport(cell: ICellViewModel): void;
    revealElementInCenter(cell: ICellViewModel): void;
    revealElementInCenterIfOutsideViewportAsync(cell: ICellViewModel): Promise<void>;
    revealNearTopIfOutsideViewportAync(cell: ICellViewModel): Promise<void>;
    revealElementLineInViewAsync(cell: ICellViewModel, line: number): Promise<void>;
    revealElementLineInCenterAsync(cell: ICellViewModel, line: number): Promise<void>;
    revealElementLineInCenterIfOutsideViewportAsync(cell: ICellViewModel, line: number): Promise<void>;
    revealElementRangeInViewAsync(cell: ICellViewModel, range: Range): Promise<void>;
    revealElementRangeInCenterAsync(cell: ICellViewModel, range: Range): Promise<void>;
    revealElementRangeInCenterIfOutsideViewportAsync(cell: ICellViewModel, range: Range): Promise<void>;
    revealElementOffsetInCenterAsync(cell: ICellViewModel, offset: number): Promise<void>;
    domElementOfElement(element: ICellViewModel): HTMLElement | null;
    focusView(): void;
    getAbsoluteTopOfElement(element: ICellViewModel): number;
    triggerScrollFromMouseWheelEvent(browserEvent: IMouseWheelEvent): void;
    delegateVerticalScrollbarPointerDown(browserEvent: PointerEvent): void;
    isElementAboveViewport(index: number): boolean;
    updateElementHeight2(element: ICellViewModel, size: number): void;
    domFocus(): void;
    focusContainer(): void;
    getViewScrollTop(): number;
    getViewScrollBottom(): number;
    private _revealOffset;
    private _revealRange;
    private _revealRangeInternalAsync;
    private _revealLineInViewAsync;
    private _revealRangeInView;
    private _revealRangeInCenterInternalAsync;
    private _revealLineInCenterAsync;
    private _revealRangeInCenterAsync;
    private _revealRangeInCenterIfOutsideViewportInternalAsync;
    private _revealIfOutsideViewportAsync;
    private _revealLineInCenterIfOutsideViewportAsync;
    private _revealRangeInCenterIfOutsideViewportAsync;
    private _revealInternal;
    private _revealInView;
    private _revealInCenter;
    private _revealInCenterIfOutsideViewport;
    setCellSelection(cell: ICellViewModel, range: Range): void;
    style(styles: IListStyles): void;
    getRenderHeight(): number;
    getScrollHeight(): number;
    layout(height?: number, width?: number): void;
    dispose(): void;
}
export declare class ListViewInfoAccessor extends Disposable {
    readonly list: INotebookCellList;
    constructor(list: INotebookCellList);
    setScrollTop(scrollTop: number): void;
    isScrolledToBottom(): boolean;
    scrollToBottom(): void;
    revealCellRangeInView(range: ICellRange): void;
    revealInView(cell: ICellViewModel): void;
    revealInViewAtTop(cell: ICellViewModel): void;
    revealInCenterIfOutsideViewport(cell: ICellViewModel): void;
    revealInCenterIfOutsideViewportAsync(cell: ICellViewModel): Promise<void>;
    revealInCenter(cell: ICellViewModel): void;
    revealNearTopIfOutsideViewportAync(cell: ICellViewModel): Promise<void>;
    revealLineInViewAsync(cell: ICellViewModel, line: number): Promise<void>;
    revealLineInCenterAsync(cell: ICellViewModel, line: number): Promise<void>;
    revealLineInCenterIfOutsideViewportAsync(cell: ICellViewModel, line: number): Promise<void>;
    revealRangeInViewAsync(cell: ICellViewModel, range: Range): Promise<void>;
    revealRangeInCenterAsync(cell: ICellViewModel, range: Range): Promise<void>;
    revealRangeInCenterIfOutsideViewportAsync(cell: ICellViewModel, range: Range): Promise<void>;
    revealCellOffsetInCenterAsync(cell: ICellViewModel, offset: number): Promise<void>;
    getViewIndex(cell: ICellViewModel): number;
    getViewHeight(cell: ICellViewModel): number;
    getCellRangeFromViewRange(startIndex: number, endIndex: number): ICellRange | undefined;
    getCellsFromViewRange(startIndex: number, endIndex: number): ReadonlyArray<ICellViewModel>;
    getCellsInRange(range?: ICellRange): ReadonlyArray<ICellViewModel>;
    setCellEditorSelection(cell: ICellViewModel, range: Range): void;
    setHiddenAreas(_ranges: ICellRange[]): boolean;
    getVisibleRangesPlusViewportAboveAndBelow(): ICellRange[];
    triggerScroll(event: IMouseWheelEvent): void;
}
